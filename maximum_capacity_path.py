from heap import Heap
import sys
from graph import Graph
from union_find import Disjoint
from element import Element
import gc
"""
Implementation of the routing algorithms:
Dijkstra without heap and heap
Kruskal
"""
UNSEEN = 1
FRINGE = 2
INTREE = 3

WHITE = 1
GRAY = 2
BLACK = 3

"""
Dijkstra's algorithm implementation without heap
"""
def get_max(fringe_list,capacity_list):
    gc.disable()
    """
    helper function to get the maximum value in the fringe list in linear time
    """
    max_v = 0
    for v in fringe_list:
        if capacity_list[v] > capacity_list[max_v]:
            max_v = v

    return max_v
    
def dijkstra(G,s,t):
    gc.disable()
    fringe = []
    capacity = [0]*(len(G)+1) #initialize capacity with the size of G and each element with 0 as values
    parent = [0]*(len(G)+1) #initialize parent with the size of G and each element with 0 as values
    status = [UNSEEN]*(len(G)+1)
    capacity[s] = sys.maxsize #the source will have the maximum capacity value
    status[s] = FRINGE
    fringe.append(s)
    
    # v is the vertex adjacent to s and c is the dictionary with the weight between them
    for v,c in G[s].items():
        parent[v] = s
        capacity[v] = c['weight']
        status[v] = FRINGE
        fringe.append(v)
    
    while len(fringe) != 0:
        u = get_max(fringe,capacity)
        fringe.remove(u)
        status[u] = INTREE
        for v,c in G[u].items(): #traverse the vertices adjacent to u
            if status[v] == UNSEEN:
                status[v] = FRINGE
                parent[v] = u
                capacity[v] = min(capacity[u],c['weight'])
                fringe.append(v)
            elif status[v] == FRINGE and capacity[v] < min(capacity[u],c['weight']):
                parent[v] = u
                capacity[v] = min(capacity[u],c['weight'])
    
    del fringe
    del capacity
    del status
    del u

    return parent
"""
Dijkstra's algorithm implementation with heap
"""
def dijkstra_heap(G,s,t):
    gc.disable()
    fringe = Heap(len(G))
    capacity = [0]*(len(G)+1) #initialize capacity with the size of G and each element with 0 as values
    parent = [0]*(len(G)+1) #initialize parent with the size of G and each element with 0 as values
    status = [UNSEEN]*(len(G)+1)
    capacity[s] = sys.maxsize #the source will have the maximum capacity value
    status[s] = FRINGE
    source = Element(s,capacity[s])
    fringe.insert(source)

    del source 
    
    for v,c in G[s].items():
        parent[v] = s
        capacity[v] = c['weight']
        status[v] = FRINGE
        v_element = Element(v,capacity[v])
        fringe.insert(v_element)
        del v_element
    
    while fringe.size != 0:
       
        u_element = fringe.maximum()
        u = u_element.name

        fringe.delete_max()
        status[u] = INTREE
        
        for v,c in G[u].items(): #traverse the vertices adjacent to u
            if status[v] == UNSEEN:
                status[v] = FRINGE
                parent[v] = u
                capacity[v] = min(capacity[u],c['weight'])

                v_element1 = Element(v,capacity[v])
                fringe.insert(v_element1)
                del v_element1
            elif status[v] == FRINGE and capacity[v] < min(capacity[u],c['weight']):
                index = fringe.get_index(v)
                
                fringe.delete(index)
                parent[v] = u
                capacity[v] = min(capacity[u],c['weight'])
                
                v_element2 = Element(v,capacity[v])
                fringe.insert(v_element2)
                del v_element2
    
    del fringe
    del capacity
    del status
    del u
    del u_element

    return parent
"""
Kruskal's algorithm implementation to generate a maximum spanning tree (uses Heapsort to sort the edges in ascending order)
"""
def kruskal(G,edgeHeap,s,t):
    gc.disable()
    edges_tree = []
    edgeHeap.heapsort()
    disjoint = Disjoint(len(G))

    #process the edges in descending order (because heapsort sorts the edges in ascending order)
    for m in xrange(edgeHeap.size,0,-1):
        if len(edges_tree) == (len(G) - 1):
            break
        u = edgeHeap.heap_array[m].name[0]
        v = edgeHeap.heap_array[m].name[1]
        
        weight = edgeHeap.heap_array[m].value
        r1 = disjoint.find(u)
        r2 = disjoint.find(v)
        if r1 != r2:
            edges_tree.append((u,v,weight))
            disjoint.union(r1,r2)
        del r1
        del r2
        del u
        del v
        del weight
    parent = dfs_kruskal(edges_tree,s,t)
    del edges_tree
    del disjoint
    return parent

"""
Depth-first search implementation to get the list of parents in order to find the path in the
maximum spanning tree generated by the function kruskal
"""
def dfs_kruskal(edges_tree,s,t):
    gc.disable()
    T = Graph(len(edges_tree)+1)
    T.add_edges(edges_tree,True)
    parent = [0]*(len(T)+1)
    color = [WHITE]*(len(T)+1) 
    
    vertices = []
    color[s] = GRAY
    vertices.append(s)
    
    while len(vertices) != 0:
        v = vertices.pop()
        for w,c in T[v].items():
            if color[w] == WHITE:
                color[w] = GRAY
                parent[w] = v
                vertices.append(w)
        color[v] = BLACK
        del v
    
    del T
    del color
    del vertices
    return parent


    
